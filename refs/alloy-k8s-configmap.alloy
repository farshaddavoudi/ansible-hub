discovery.kubernetes "pods" {
  role = "pod"
}

discovery.relabel "pod_logs" {
  targets = discovery.kubernetes.pods.targets

  // Static source label
  rule {
    target_label  = "source"
    replacement   = "k8s"
  }

  // service_name as label
  rule {
    source_labels = ["__meta_kubernetes_namespace"]
    target_label  = "service_name"
  }

  // namespace as field
  rule {
    source_labels = ["__meta_kubernetes_namespace"]
    target_label  = "__field_namespace"
  }

  // Category = container name as label
  rule {
    source_labels = ["__meta_kubernetes_pod_container_name"]
    target_label  = "category"
  }

  // container name as field
  rule {
    source_labels = ["__meta_kubernetes_pod_container_name"]
    target_label  = "__field_container_name"
  }

  // pod name → keep as field (not label)
  rule {
    source_labels = ["__meta_kubernetes_pod_name"]
    target_label  = "__field_pod"
  }

  // container id → keep as field
  rule {
    source_labels = ["__meta_kubernetes_pod_container_id"]
    target_label  = "__field_container_id"
  }

  // node name → keep as field
  rule {
    source_labels = ["__meta_kubernetes_node_name"]
    target_label  = "__field_node"
  }

  // Build log file path
  rule {
    source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
    separator     = "/"
    action        = "replace"
    replacement   = "/var/log/pods/*$1/*.log"
    target_label  = "__path__"
  }

  // Extract container runtime type as field
  rule {
    action        = "replace"
    source_labels = ["__meta_kubernetes_pod_container_id"]
    regex         = "^(\\w+):\\/\\/.+$"
    replacement   = "$1"
    target_label  = "__field_container_runtime"
  }
}

local.file_match "pod_logs" {
  path_targets = discovery.relabel.pod_logs.output
}

loki.source.file "pod_logs" {
  targets    = local.file_match.pod_logs.targets
  forward_to = [loki.process.pod_logs.receiver]
}

loki.process "pod_logs" {
  // Apply container runtime parsers
  stage.match {
    selector = "{__field_container_runtime=\"containerd\"}"
    stage.cri {}
  }
  stage.match {
    selector = "{filename=~\"/var/log/pods/.+/0.log\"}"
    stage.cri {}
  }
  stage.match {
    selector = "{__field_container_runtime=\"docker\"}"
    stage.docker {}
  }

  // --- Multiline parsing: join lines belonging to one error
  stage.multiline {
    firstline    = `^\[\d{2}:\d{2}:\d{2} (ERR|WRN|INF|DBG|CRIT)\]`
    max_wait_time = "3s"
  }

  // --- Log level detection inside the multiline batch
  stage.regex {
    expression = "(?i)(?P<raw_level>ERR|ERROR|WRN|WARN|WARNING|INF|INFO|CRIT|FATAL)"
  }

  stage.replace {
    source     = "raw_level"
    expression = "(?i)ERR|ERROR"
    replace    = "error"
  }
  stage.replace {
    source     = "raw_level"
    expression = "(?i)WRN|WARN|WARNING"
    replace    = "warning"
  }
  stage.replace {
    source     = "raw_level"
    expression = "(?i)INF|INFO"
    replace    = "info"
  }
  stage.replace {
    source     = "raw_level"
    expression = "(?i)CRIT|FATAL"
    replace    = "critical"
  }

  // Attach the normalized log level as a log label
  stage.labels {
    values = {
      level = "",
    }
  }

  forward_to = [loki.write.k8s_loki.receiver]
}

loki.write "k8s_loki" {
  endpoint {
    url = "http://192.168.1.80:3100/loki/api/v1/push"
  }
}